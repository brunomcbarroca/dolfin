#!/usr/bin/env python
#
# Copyright (C) 2010 Garth N. Wells
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# Generate CMakeLists.txt files in demo and test directories
# This script should be run from the top level directory.
#
# Modified by Anders Logg 2013, 2014

from __future__ import print_function

import sys
import os
import subprocess


cmakelists_str = \
"""# This file is automatically generated by running
#
#     cmake/scripts/generate-cmakefiles
#
# Require CMake 2.8
cmake_minimum_required(VERSION 2.8)

set(PROJECT_NAME %(project_name)s)
project(${PROJECT_NAME})

# Set verbose output while testing CMake
#set(CMAKE_VERBOSE_MAKEFILE 1)

# Set CMake behavior
cmake_policy(SET CMP0004 NEW)

# Get DOLFIN configuration data (DOLFINConfig.cmake must be in
# DOLFIN_CMAKE_CONFIG_PATH)
find_package(DOLFIN REQUIRED)

if (EXISTS ${DOLFIN_USE_FILE})
  include(${DOLFIN_USE_FILE})

  # Default build type (can be overridden by user)
  if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "RelWithDebInfo" CACHE STRING
      "Choose the type of build, options are: Debug MinSizeRel Release RelWithDebInfo." FORCE)
  endif()

  # Do not throw error for 'multi-line comments' (these are typical in
  # rst which includes LaTeX)
  include(CheckCXXCompilerFlag)
  CHECK_CXX_COMPILER_FLAG("-Wno-comment" HAVE_NO_MULTLINE)
  if (HAVE_NO_MULTLINE)
    set(CMAKE_CXX_FLAGS "-Wno-comment ${CMAKE_CXX_FLAGS}")
  endif()

else()
  # Compiler definitions
  add_definitions(${DOLFIN_CXX_DEFINITIONS})

  # Compiler flags
  set(CMAKE_CXX_FLAGS "${DOLFIN_CXX_FLAGS} ${CMAKE_CXX_FLAGS}")

  # Do not throw error for 'multi-line comments' (these are typical in
  # rst which includes LaTeX)
  include(CheckCXXCompilerFlag)
  CHECK_CXX_COMPILER_FLAG("-Wno-comment" HAVE_NO_MULTLINE)
  if (HAVE_NO_MULTLINE)
    set(CMAKE_CXX_FLAGS "-Wno-comment ${CMAKE_CXX_FLAGS}")
  endif()

  # Include directories
  include_directories(${DOLFIN_INCLUDE_DIRS})
  include_directories(SYSTEM ${DOLFIN_3RD_PARTY_INCLUDE_DIRS})
endif()

# List all ufl files to compile
set(UFL_FILENAMES %(ufl_files)s)

# Pick one of these:
# 1) Place generated files in source directory
#set(GENERATED_DIR ${CMAKE_SOURCE_DIR})
# 2) Place generated files in build directory
set(GENERATED_DIR ${CMAKE_BINARY_DIR})

# Assuming ufl files lie in the source dir
set(UFL_FILES_DIR ${CMAKE_SOURCE_DIR})

foreach(UFL_FILENAME ${UFL_FILENAMES})
  get_filename_component(UFL_BASENAME ${UFL_FILENAME} NAME_WE)
  add_custom_command(
    OUTPUT ${GENERATED_DIR}/${UFL_BASENAME}.h ${GENERATED_DIR}/${UFL_BASENAME}.cpp
    COMMAND ffc -l dolfin -fsplit --output-directory ${GENERATED_DIR} ${UFL_FILENAME}
    MAIN_DEPENDENCY ${UFL_FILENAME}
    WORKING_DIRECTORY ${UFL_FILES_DIR}
    COMMENT Running FEniCS Form Compiler on ${UFL_FILENAME}.
    )
  set(UFL_GENERATED_SOURCES ${UFL_GENERATED_SOURCES} ${GENERATED_DIR}/${UFL_BASENAME}.cpp)
endforeach(UFL_FILENAME)

# Make generated headers available
include_directories(${GENERATED_DIR})

# Executable
%(executables)s

# Target libraries
%(target_libraries)s
"""

# Templates for each line in %(executables)s and %(target_libraries)s
executable_str = "add_executable(%s %s ${UFL_GENERATED_SOURCES})"
target_link_libraries_str = "target_link_libraries(%s ${DOLFIN_LIBRARIES})"


# Subdirectories
sub_directories = ['demo', 'bench']

# Prefix map for subdirectories
executable_prefixes = dict(demo="demo_",
                           bench="bench_")

# Projects that use custom CMakeLists.txt (shouldn't overwrite)
#exclude_projects = [os.path.join('demo', 'undocumented', 'plot-qt')]
exclude_projects = []


def generate_cmake_files(subdirectory):
    """Search for C++ code and write CMakeLists.txt files"""
    generated_files = []
    cwd = os.getcwd()
    executable_prefix = executable_prefixes[subdirectory]
    executable_names = set()
    for root, dirs, _unused_files in os.walk(os.path.join(cwd, subdirectory)):
        # Only handle 'cpp' dirs
        if "cpp" not in dirs:
            continue
        if any(exclude in root for exclude in exclude_projects):
            print("Skipping custom CMakeLists.txt file (excluded):", root)
            continue

        # Get directory and name of demo program
        program_dir = os.path.join(root, "cpp")
        program_name = os.path.split(root)[-1]
        if executable_prefix == "bench_":
            program_name = program_dir[program_dir.find("bench")+6:].replace(os.path.sep, "_")

        # Check for duplicate executable names
        if program_name not in executable_names:
            executable_names.add(program_name)
        else:
            print("Warning: duplicate executable names found when generating CMakeLists.txt files.")

        # Define project name
        project_name = executable_prefix + program_name

        # Get list of .cpp and .ufl files
        cpp_files = set()
        ufl_files = set()
        for f in os.listdir(program_dir):
            filename, extension = os.path.splitext(f)
            if extension == ".cpp":
                cpp_files.add(f)
            elif ".cpp.rst" in f:
                cpp_files.add(filename)
            elif extension == ".ufl":
                ufl_files.add(f)

        # Make sure ufl-generated files are not in the regular cpp_files list
        for f in ufl_files:
            fcpp = f.replace(".ufl", ".cpp")
            if fcpp in cpp_files:
                cpp_files.remove(fcpp)

        # If no .cpp, skip
        if not cpp_files:
            #print("Skipping custom CMakeLists.txt file (no .cpp file found):", root)
            continue

        # For determinism
        cpp_files = sorted(cpp_files)

        # Format as cmake list
        ufl_files = ";".join(sorted(ufl_files))

        # Compile one or multiple executables:
        if "main.cpp" in cpp_files:
            # If directory contains a main.cpp file we assume that only one
            # executable should be generated for this directory and all other
            # .cpp files should be linked to this
            executables = executable_str % ("${PROJECT_NAME}", ' '.join(cpp_files))
            target_libraries = target_link_libraries_str % ("${PROJECT_NAME}",)
        else:
            # If no main file among source files, we assume each source should
            # be compiled as a separate executable
            executables = "\n".join(
                executable_str % (executable_prefix + f.replace(".cpp", ""), f)
                for f in cpp_files)
            target_libraries = "\n".join(
                target_link_libraries_str % (
                    executable_prefix + f.replace(".cpp", ""))
                for f in cpp_files)

        # Format content of CMakeLists.txt from templates
        cmakelists_content = cmakelists_str % dict(
            project_name=project_name,
            executables=executables,
            target_libraries=target_libraries,
            ufl_files=ufl_files,
            )

        # Write file
        filename = os.path.join(program_dir, "CMakeLists.txt")
        generated_files.append(filename)
        with open(filename, "w") as f:
            #print("Creating CMakeLists.txt file:", program_name, program_dir)
            f.write(cmakelists_content)

    return generated_files


def main():
    # Generate CMakeLists.txt files for all subdirectories
    generated_files = []
    for subdirectory in sub_directories:
        generated_files.extend(generate_cmake_files(subdirectory))

    # Print list of generated files
    print("The following files were generated:")
    print("\n".join(generated_files))

    return 0

if __name__ == "__main__":
    sys.exit(main())
