#!/usr/bin/env python
#
# Copyright (C) 2010 Garth N. Wells
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# Generate CMakeLists.txt files in demo and test directories
# This script should be run from the top level directory.
#
# Modified by Anders Logg 2013, 2014

from __future__ import print_function

import sys
import os
import subprocess


cmakelists_str = \
"""# This file is automatically generated by running
#
#     cmake/scripts/generate-cmakefiles
#
# Require CMake 2.8
cmake_minimum_required(VERSION 2.8)

set(PROJECT_NAME %(project_name)s)
project(${PROJECT_NAME})

# Set verbose output while testing CMake
#set(CMAKE_VERBOSE_MAKEFILE 1)

# Set CMake behavior
cmake_policy(SET CMP0004 NEW)


# Get DOLFIN configuration data (DOLFINConfig.cmake must be in
# DOLFIN_CMAKE_CONFIG_PATH)
find_package(DOLFIN REQUIRED)

if (EXISTS ${DOLFIN_USE_FILE})
  include(${DOLFIN_USE_FILE})

  # Default build type (can be overridden by user)
  if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "RelWithDebInfo" CACHE STRING
      "Choose the type of build, options are: Debug MinSizeRel Release RelWithDebInfo." FORCE)
  endif()

else()
  # Compiler definitions
  add_definitions(${DOLFIN_CXX_DEFINITIONS})

  # Compiler flags
  set(CMAKE_CXX_FLAGS "${DOLFIN_CXX_FLAGS} ${CMAKE_CXX_FLAGS}")

  # Include directories
  include_directories(${DOLFIN_INCLUDE_DIRS})
  include_directories(SYSTEM ${DOLFIN_3RD_PARTY_INCLUDE_DIRS})
endif()


# Do not throw error for 'multi-line comments' (these are typical in
# rst which includes LaTeX)
include(CheckCXXCompilerFlag)
CHECK_CXX_COMPILER_FLAG("-Wno-comment" HAVE_NO_MULTLINE)
if (HAVE_NO_MULTLINE)
  set(CMAKE_CXX_FLAGS "-Wno-comment ${CMAKE_CXX_FLAGS}")
endif()


### Running pylit
# HACK to make pylit available without installation.
# Should be fixed somehow, e.g. by posting pylit on pypi to make it pip installable.
set(PYLIT %(pylit)s)

# List all .foo.rst files to translate with pylit
set(RST_FILENAMES %(rst_files)s)

# Pick one of these:
# 1) Place generated files in source directory
set(PYLIT_OUTPUT_DIR ${CMAKE_SOURCE_DIR})
# 2) Place generated files in build directory (needs some adjustment of paths below to work)
#set(PYLIT_OUTPUT_DIR ${CMAKE_BINARY_DIR})

# Tell cmake how to run pylit on each *.*.rst file
foreach(RST_FILENAME ${RST_FILENAMES})
  # Get foo.cpp from foo.cpp.rst, cannot use get_filename_component because
  # it drops the .cpp part as well, and want to handle cpp,h,py,ufl files.
  string(REGEX REPLACE "\\\\.[^.]*$" "" RST_BASENAME ${RST_FILENAME})
  add_custom_command(
    OUTPUT ${PYLIT_OUTPUT_DIR}/${RST_BASENAME}
    MAIN_DEPENDENCY ${RST_FILENAME}
    WORKING_DIRECTORY ${PYLIT_OUTPUT_DIR}
    COMMAND ${PYLIT} ${CMAKE_SOURCE_DIR}/${RST_FILENAME}
    COMMENT Running pylit on ${RST_FILENAME}.
    )
endforeach(RST_FILENAME)


### Running ffc
# List all .ufl files to compile with ffc
set(UFL_FILENAMES %(ufl_files)s)

# Pick one of these:
# 1) Place generated files in source directory
#set(FFC_OUTPUT_DIR ${CMAKE_SOURCE_DIR})
# 2) Place generated files in build directory and make headers includable
set(FFC_OUTPUT_DIR ${CMAKE_BINARY_DIR})
include_directories(${FFC_OUTPUT_DIR})

# Tell cmake how to run ffc on each .ufl file
foreach(UFL_FILENAME ${UFL_FILENAMES})
  get_filename_component(UFL_BASENAME ${UFL_FILENAME} NAME_WE)
  add_custom_command(
    OUTPUT ${FFC_OUTPUT_DIR}/${UFL_BASENAME}.h ${FFC_OUTPUT_DIR}/${UFL_BASENAME}.cpp
    MAIN_DEPENDENCY ${UFL_FILENAME}
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMAND ffc -l dolfin -fsplit --output-directory ${FFC_OUTPUT_DIR} ${UFL_FILENAME}
    COMMENT Running FEniCS Form Compiler on ${UFL_FILENAME}.
    )
  # Accumulate list of generated sources to compile into executable
  set(FFC_GENERATED_SOURCES ${FFC_GENERATED_SOURCES} ${FFC_OUTPUT_DIR}/${UFL_BASENAME}.cpp)
endforeach(UFL_FILENAME)


### Defining target(s)
# Define executables
%(executables)s

# Link to libraries
%(target_libraries)s
"""

# HACK to make pylit available without installation.
# Should be fixed somehow, e.g. by posting pylit on pypi to make it pip installable.
pylit = os.path.abspath(os.path.join(os.getcwd(), "utils/pylit/pylit.py"))

# Templates for each line in %(executables)s and %(target_libraries)s
executable_str = "add_executable(%s %s ${FFC_GENERATED_SOURCES})"
target_link_libraries_str = "target_link_libraries(%s ${DOLFIN_LIBRARIES})"


# Subdirectories
sub_directories = ['demo', 'bench']

# Prefix map for subdirectories
executable_prefixes = dict(demo="demo_",
                           bench="bench_")

# Projects that use custom CMakeLists.txt (shouldn't overwrite)
#exclude_projects = [os.path.join('demo', 'undocumented', 'plot-qt')]
exclude_projects = []

def generate_cmake_files(subdirectory):
    """Search for C++ code and write CMakeLists.txt files"""
    generated_files = []
    cwd = os.getcwd()
    executable_prefix = executable_prefixes[subdirectory]
    executable_names = set()
    for root, dirs, _unused_files in os.walk(os.path.join(cwd, subdirectory)):
        # Only handle 'cpp' dirs
        if "cpp" not in dirs:
            continue
        if any(exclude in root for exclude in exclude_projects):
            print("Skipping custom CMakeLists.txt file (excluded):", root)
            continue

        # Get directory and name of demo program
        program_dir = os.path.join(root, "cpp")
        program_name = os.path.split(root)[-1]
        if executable_prefix == "bench_":
            program_name = program_dir[program_dir.find("bench")+6:].replace(os.path.sep, "_")

        # Check for duplicate executable names
        if program_name not in executable_names:
            executable_names.add(program_name)
        else:
            print("Warning: duplicate executable names found when generating CMakeLists.txt files.")

        # Define project name
        project_name = executable_prefix + program_name

        # Get list of .rst, .ufl, and .cpp files
        rst_files = set()
        ufl_files = set()
        cpp_files = set()
        for f in os.listdir(program_dir):
            filename, extension = os.path.splitext(f)
            if extension == ".rst":
                # filename is without the .rst extension:
                subext = os.path.splitext(filename)[1]
                if subext:
                    # Add any file foo.subext.rst to rst_files
                    rst_files.add(f)
                    # Add foo.ufl or foo.cpp to their respective lists
                    if subext == ".ufl":
                        ufl_files.add(filename)
                    elif subext == ".cpp":
                        cpp_files.add(filename)
            elif extension == ".ufl":
                ufl_files.add(f)
            elif extension == ".cpp":
                cpp_files.add(f)

        # Make sure ufl-generated files are not in the regular cpp_files list
        for f in ufl_files:
            fcpp = f.replace(".ufl", ".cpp")
            if fcpp in cpp_files:
                cpp_files.remove(fcpp)

        # If no .cpp, skip
        if not cpp_files:
            #print("Skipping custom CMakeLists.txt file (no .cpp file found):", root)
            continue

        # Sort for determinism and format as cmake lists and 
        rst_files = " ".join(sorted(rst_files))
        ufl_files = " ".join(sorted(ufl_files))
        cpp_files = sorted(cpp_files)

        # Compile one or multiple executables:
        if "main.cpp" in cpp_files:
            # If directory contains a main.cpp file we assume that only one
            # executable should be generated for this directory and all other
            # .cpp files should be linked to this
            executables = executable_str % ("${PROJECT_NAME}", ' '.join(cpp_files))
            target_libraries = target_link_libraries_str % ("${PROJECT_NAME}",)
        else:
            # If no main file among source files, we assume each source should
            # be compiled as a separate executable
            executables = "\n".join(
                executable_str % (executable_prefix + f.replace(".cpp", ""), f)
                for f in cpp_files)
            target_libraries = "\n".join(
                target_link_libraries_str % (
                    executable_prefix + f.replace(".cpp", ""))
                for f in cpp_files)

        # Format content of CMakeLists.txt from templates
        cmakelists_content = cmakelists_str % dict(
            project_name=project_name,
            executables=executables,
            target_libraries=target_libraries,
            pylit=pylit,
            rst_files=rst_files,
            ufl_files=ufl_files,
            )

        # Write file
        filename = os.path.join(program_dir, "CMakeLists.txt")
        generated_files.append(filename)
        with open(filename, "w") as f:
            #print("Creating CMakeLists.txt file:", program_name, program_dir)
            f.write(cmakelists_content)

    return generated_files


def main():
    # Generate CMakeLists.txt files for all subdirectories
    generated_files = []
    for subdirectory in sub_directories:
        generated_files.extend(generate_cmake_files(subdirectory))

    # Print list of generated files
    print("The following files were generated:")
    print("\n".join(generated_files))

    return 0

if __name__ == "__main__":
    sys.exit(main())
